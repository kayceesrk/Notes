---
layout: post
title: "Is the context ready?"
date: 2014-05-10 14:37:00
categories: Research Notes
---

In this post, we will discuss the idea and the strategy for determining

1. <a name="Q1"></a> whether a context is ready for discharging a coordination free operation (Q1)
2. <a name="Q2"></a> if not, what are the effects that are missing, and (Q2)
3. <a name="Q3"></a> are there effects that can be ignored from a context so
that we can discharge the operation (Q3).

We say that a context is *ready* if all the necessary visibility expectations of
an operation can possibly be obtained. Let us consider an example in order to
make things clear. Suppose we have a read-my-writes specification attached to an
operation O.

{% highlight haskell %}
rmw :: Spec
rmw x = forall_ $ \y -> so y x ==> vis y x
{% endhighlight %}

The expectation is that, when O is performed, any effects generated by O must
witness all the effects that have been previously performed in the same session.
Of course, we can determine that the rmw specification itself is coordination
free [statically][isCoordFree]. Given that a specification is coordination free,
the challenge is to determine **at runtime** when to discharge the operation
such that all effects that happened before in the same session are visible.

# Model

To appreciate the problem, we should consider the runtime model of our system.
At the lowest level in the storage hierarchy, we have Cassandra, which is a
which is a column-oriented distributed, eventually consistent data store.
Cassandra is a glorified key-value store, where the values are a set of columns.
The schema that we use for the Cassandra storage (represented as a Haskell type)
is:

{% highlight haskell %}
data Addr = Addr { sess :: UUID, idx  :: Int }

table <TableName> a = {
  key   :: UUID,     -- Key
  sess  :: UUID,     -- Session identifier
  idx   :: Int,      -- index of the effect within a given session
  vis   :: Set Addr, -- visibility set
  value :: a,        -- value
} primary key (key, sess, idx)
{% endhighlight %}


Each record corresponds to a single high-level effect on a particular object
with some key (k). Thus, each table is a collection of objects where the set of
records with the same key (k) is the set of all effects performed on this object,
say o. Each operation in Codeec is applied on a particular key (k) on a
particular table (t). Before performing the operation, we read the corresponding
set of records (effects) with the same key k from the corresponding Cassandra
table. By utilizing the visibility information (vis) in each record, we can
construct the context over which the operation is applied. Recall that a context
is nothing but a directed graph where each node is a value associated with the
effect, and the edges capture the visibility information.

# Known effects

The set of effects returned by reading the table (and present in the context)
are the candidates for effects visible to the effect produced by the operation
for which the context is constructed. Let us call any effect that is in the
context to be *known*. The key observation is that such a set of known effects
might

1. include certain effects that are not necessary
2. exclude certain effects that are necessary

for satisfying the visibility obligation for the effect produced by the
operation.

Let us consider an example. Suppose we are about to operation an operation (O)
in session (s1) which will produce an effect (x), and the specification attached
to the operation is read-my-writes (rmw) defined previously. For performing O,
we read the Cassandra table, let us assume that we have the following context:

{% highlight OCaml %}
Session S1    Session S2
----------    ----------
 {a}(0)          {d}(0)
   |               |
   v               v
  b(1)<---vis----{e}(1)
   |
   v
  c(2)
{% endhighlight %}

The numbers in the brackets correspond to the index of the action within a
session (the index starts at 0). Assume that the actions enclosed in curly
braces are unknown (not present in the context); we do know about the existence
of unknown actions by the fact that index starts at 0, and through the set of
visible addresses (vis) associated with each record returned by selection on
Cassandra table.

In this example, the selection on Cassandra table returned two effects (record)
corresponding to b and c. We knew through the index field in the record
(index(b) = 1 and index(c) = 2) that there must necessarily exist some unknown a
with index 0 in session S1. We knew through the vis field of b that there exists
an unknown effect e performed on session S2 with index 1 (which in turn reveals
the existence of effect d).

# Known effects and the obligation of specification

The first question to ask is whether we can perform the operation O in the
context where b and c are known and a, d and e are unknown ([Q1](#Q1)).
Read-my-writes obligates that the effect x (produced by O) must witness the
unknown effect a performed previously in the same session. Hence, we cannot
discharge O under this context. We say that this context is not ready for
discharging O. Moreover, a is the *only* effect that is necessary to discharge
O. Read my writes does not obligate that the effects e and d need to be
witnessed. This is the answer to [Q2](#Q2).

# Ignorance is bliss

Suppose the specification attached with O happened to be causal visibility

{% highlight haskell %}
cvis :: Spec
cvis x = forall_ $ \y -> hb x y ==> vis x y
{% endhighlight %}

where hb is a transitive closure over session order and visibility. Suppose we
had the following context:

{% highlight OCaml %}
Session S1    Session S2    Session S3
----------    ----------    ----------
  a(0)           .....         .....
   |               |             |
   v               v             v
  b(1)         {d}(9999)      {e}(XXX)
                   |             /
                   v            /
                c(10000)<--vis--
{% endhighlight %}

In this context, a, b and c are known. But the context is not ready since the
effects that causally precede c are not known. The set of effects causally
preceding c can be very large, and might only become visible after an arbitrary
delay. So should we wait until all such operations are known before we discharge
O?

Luckily, the answer is no. The key observation is that an effect that is known
need not necessarily be made visible to an operation. The implementation has
control over the visibility of effects to the current operation. In this case,
instead of including c in the context, which obligates the visibility of unknown
actions d, e and others, we can ignore c, and only consider the context:

{% highlight OCaml %}
Session S1
----------
  a(0)
   |
  b(1)
{% endhighlight %}

This context is ready to perform O with causal visibility as its specification.
Thus, we can immediately discharge the operation without waiting further. The
idea of [Q3](#Q3) is that given the original known set K, whether it is possible
to derive a subset of the known set K' which is ready to perform the operation O
with specification S.

# Discharging the queries through Z3

TODO.

[isCoordFree]: http://rise4fun.com/Z3/fEkNc
[Q1Z3]: http://rise4fun.com/Z3/enfk
[Q2Z3]:
