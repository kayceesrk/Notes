---
layout: post
title:  "Codeec Consistency Specification and Analysis"
date:   2014-04-15 16:20:24
categories: Research Notes
---

In the [previous post][prev-post], we had seen a Codeec definition of a bank
account with deposit, withdraw and getBalance operations. Any reasonable
implementation of a bank account can expect certain consistency guarantees. In
the context of our implementation of bank account, we can expect a guarantee
that

	The balance in any account never goes below zero. (1)

On an eventually consistent system, enforcing this guarnatee requires subtle
program reasoning. Naively, one can get this guarantee simply by enforcing
linarizability of all operations performed on a particular account. However,
linearizability is too strong for the purpose; two deposit operations need not
immediately witness the effect of each other to ensure (1). Hence, we will try
to answer the following questions. For Codeec programs running over eventually
consistent distributed stores (ECDS),

* How do we precisely express the application-level consistency guarantees?
* How does the system enforce the guarantees?

Our intention is to express the the application-level consistency guarantees
through **specifications** and analyze the specification to derive:

1. **Coordination Freedom:** Whether it is possible to discharge the consistency check without
coordination?
2. What information needs to be tracked by the implementation to discharge the
local consistency checks (pre-condition for operations)?

</br>
# Coordination Freedom

Specification language:

<div>
\[
\newcommand{\ALT}{~|~}
\newcommand{\speci}{\overline{\forall a}. \lambda x.\phi_1 \Rightarrow \phi_2}
\newcommand{\specii}{\overline{\forall a}. \lambda x.\phi}
\newcommand{\cf}[1]{CoordFree(#1)}
\begin{array}{rcl}
spec & := 	&  \speci \ALT \specii \\
\phi & := 	& True \ALT vis(a,b) \ALT so(a,b) \ALT \phi \odot \phi \\
\odot & := & \wedge \ALT \vee
\end{array}
\]
</div>

Let $k(x)$ indicate that $x$ is known. We want to know whether a specification
of the form $\speci$ or $\specii$ (where $x$ is the current action $-$ the
action (potentially) generated by the operation under focus) can be locally
checked i.e. without requiring global knowledge. We will utilize an analysis
$\cf{spec}$ which holds if the specification can be locally discharged without
requiring global knowledge (coordination). Of course, we assume that the
specification does not introduce logical inconsistencies. For example, the
following are logically inconsistent specifications:

* $\lambda x. vis(x,x)$ - visibility is irreflexive.
* $\forall a. \lambda x.so(a,x) \Rightarrow so(x,a)$ - session order is total.
* $\forall a,b. \lambda x. so(a,x) \wedge vis (b,a) \Rightarrow vis(x,b)$ - happens-before is acyclic.

The logically inconsistent specifications are weeded out using the SMT solver
and the set of basic axioms. This **Coordination Freedom** analysis is defined
below:

<div>
\[
\newcommand{\cfxto}{~\overset{ext}{\longrightarrow}~}
\newcommand{\cfcto}{~\overset{chk}{\longrightarrow}~}
\newcommand{\rulesep}{\;\;\;\;\;\;}
\frac{k(x) \vdash \phi_1 ~\overset{ext~*}{\longrightarrow}~ \Gamma \vdash True \rulesep
      \Gamma \vdash \phi_2 ~\overset{chk~*}{\longrightarrow}~ \Gamma \vdash True}
     {\cf{\speci}} \rulesep

\frac{k(x) \vdash \phi ~\overset{chk~*}{\longrightarrow}~ \Gamma \vdash True}
     {\cf{\specii}}
\]
</div>

where

<div>
\[
\begin{array}{rcl}
\Gamma \vdash True \odot \phi & \cfcto & \Gamma \vdash \phi \\
\Gamma, k(a), k(b) \vdash vis(a,b) \odot \phi & \cfcto & \Gamma, k(a), k(b) \vdash \phi \\
\Gamma, k(a), k(b) \vdash so(a,b) \odot \phi & \cfcto & \Gamma, k(a), k(b) \vdash \phi \\ \\
\Gamma \vdash True \odot \phi & \cfxto & \Gamma \vdash \phi \\
\Gamma, k(b) \vdash vis(a,b) \odot \phi & \cfxto & \Gamma, k(a), k(b) \vdash \phi \\
\Gamma, k(b) \vdash so(a,b) \odot \phi & \cfxto & \Gamma, k(a), k(b) \vdash \phi

\end{array}
\]
</div>

## Examples

[prev-post]: http://multimlton.cs.purdue.edu/mML/Notes/research/notes/2014/04/10/Codeec-surface-language.html
