---
layout: post
title:  "Codeec Consistency Specification and Analysis"
date:   2014-04-15 16:20:24
categories: Research Notes
---

The `CoordFree` analysis described in this article is deprecated. See the [new
CoordFree analysis][CoordFree].

In the [previous post][prev-post], we had seen a Codeec definition of a bank
account with deposit, withdraw and getBalance operations. Any reasonable
implementation of a bank account can expect certain consistency guarantees. In
the context of our implementation of bank account, we can expect a guarantee
that

	The balance in any account never goes below zero. (1)

On an eventually consistent system, enforcing this guarantee requires subtle
program reasoning. Naively, one can get this guarantee simply by enforcing
linearizability of all operations performed on a particular account. However,
linearizability is too strong for the purpose; two deposit operations need not
immediately witness the effect of each other to ensure (1). Hence, we will try
to answer the following questions. For Codeec programs running over eventually
consistent distributed stores (ECDS),

* How do we precisely express the application-level consistency guarantees?
* How does the system enforce the guarantees?

Our intention is to express the the application-level consistency guarantees
through **specifications** and analyze the specification to derive:

1. **Coordination Freedom:** Whether it is possible to discharge the consistency check without
coordination?
2. What information needs to be tracked by the implementation to discharge the
local consistency checks (pre-condition for operations)?

</br>
# Coordination Freedom

Specification language:

<div>
\[
\newcommand{\ALT}{~|~}
\newcommand{\speci}{\overline{\forall a}. \lambda x.\phi_1 \Rightarrow \phi_2}
\newcommand{\specii}{\overline{\forall a}. \lambda x.\phi}
\newcommand{\cf}[1]{CoordFree(#1)}
\begin{array}{rcl}
spec & := 	&  \speci \ALT \specii \\
\phi & := 	& True \ALT vis(a,b) \ALT so(a,b) \ALT \phi \odot \phi \\
\odot & := & \wedge \ALT \vee
\end{array}
\]
</div>

Let $k(x)$ indicate that $x$ is known. We want to know whether a specification
of the form $\speci$ or $\specii$ (where $x$ is the current action $-$ the
action (potentially) generated by the operation under focus) can be locally
checked i.e. without requiring global knowledge. We will utilize an analysis
$\cf{spec}$ which holds if the specification can be locally discharged without
requiring global knowledge (coordination). Of course, we assume that the
specification does not introduce logical inconsistencies. For example, the
following are logically inconsistent specifications:

* $\lambda x. vis(x,x)$ - visibility is irreflexive.
* $\forall a. \lambda x.so(a,x) \Rightarrow so(x,a)$ - session order is total.
* $\forall a,b. \lambda x. so(a,x) \wedge vis (b,a) \Rightarrow vis(x,b)$ - happens-before is acyclic.

The logically inconsistent specifications are weeded out using the SMT solver
and the set of basic axioms. This **Coordination Freedom** analysis is defined
below:

<div>
\[
\newcommand{\cfxto}{~\overset{ext}{\longrightarrow}~}
\newcommand{\cfcto}{~\overset{chk}{\longrightarrow}~}
\newcommand{\rulesep}{\;\;\;\;\;\;}
\frac{k(x) \vdash \phi_1 ~\overset{ext~*}{\longrightarrow}~ \Gamma \vdash True \rulesep
      \Gamma \vdash \phi_2 ~\overset{chk~*}{\longrightarrow}~ \Gamma \vdash True}
     {\cf{\speci}} \rulesep

\frac{k(x) \vdash \phi ~\overset{chk~*}{\longrightarrow}~ \Gamma \vdash True}
     {\cf{\specii}}
\]
</div>

where

<div>
\[
\begin{array}{rcll}
\Gamma \vdash True \odot \phi & \cfcto & \Gamma \vdash \phi & (C.1)\\
\Gamma, k(a), k(b) \vdash vis(a,b) \odot \phi & \cfcto & \Gamma, k(a), k(b) \vdash True \odot \phi & (C.2)\\
\Gamma, k(a), k(b) \vdash so(a,b) \odot \phi & \cfcto & \Gamma, k(a), k(b) \vdash True \odot \phi & (C.3) \\ \\
\Gamma \vdash True \odot \phi & \cfxto & \Gamma \vdash \phi & (E.1) \\
\Gamma, k(b) \vdash vis(a,b) \odot \phi & \cfxto & \Gamma, k(a), k(b) \vdash True \odot \phi & (E.2) \\
\Gamma, k(b) \vdash so(a,b) \odot \phi & \cfxto & \Gamma, k(a), k(b) \vdash True \odot \phi & (E.3)

\end{array}
\]
</div>

## Examples

### Read-my-writes

Read-my-writes is coordination free, and can be discharged locally.
Read-my-writes is expressed as $rmw = \forall a. \lambda x. so(a,x) \Rightarrow
vis(a,x)$. Now,

<div>
\[
\newcommand{\doExt}{~\overset{ext~*}{\longrightarrow}~}
\newcommand{\doChk}{~\overset{chk~*}{\longrightarrow}~}
k(x) \vdash so(a,x) \doExt k(x), k(a) \vdash True \\
k(x), k(a) \vdash vis(a,x) \doChk k(x), k(a) \vdash True
\]
</div>

Hence, $\cf{rmw}$ holds.

### Causal visibility

Causal visibility is defined as $cau = \forall a,b. \lambda x. vis(a,b) \wedge
vis(b,x) \Rightarrow vis(a,x)$. Now,

<div>
\[
k(x) \vdash vis(b,x) \wedge vis(a,b) \doExt k(x), k(b) \vdash vis(a,b) \doChk k(x),k(a),k(b) \vdash True \\
k(x),k(a),k(b) \vdash vis(a,x) \doChk k(x),k(a),k(b) \vdash True \\
\]
</div>

Hence, $\cf{cau}$ holds.

### Total order

Total order is defined by $total = \forall a. \lambda x. vis(a,x) \vee
vis(x,a)$. Now, the reduction

<div>
\[
k(x) \vdash vis(a,x) \vee vis(x,a) \doChk \ldots
\]
</div>

gets stuck. Hence, $\cf{total}$ does not hold. For the same reason, initial
action $init = \forall a. \lambda x. vis (x,a)$ and final action $final =
\forall a. \lambda x. vis(a,x)$ are also not coordination free.

### Total order on visible

Consider a modified definition of total order only on actions visible to the
current action $visTotal = \forall a,b. \lambda x. vis(a,x) \wedge vis(b,x)
\Rightarrow vis(a,b)$. Notice that $\cf{visTotal}$ holds. This only says that
eventually we can discharge the consistency obligation. But it can certainly be
the case that $a$ and $b$ are concurrent operations visible to the current
action $x$ but not visible to each other.

The distinction can be understood through the analogy of data races in
concurrent programs. Our goal is to enforce data race freedom in our programs.
But the local specifications only allow us to detect data races.

What we need is a syntactically restricted form of the specification language
that is by construction locally *enforceable*.

[prev-post]: http://multimlton.cs.purdue.edu/mML/Notes/research/notes/2014/04/10/Codeec-surface-language.html
[CoordFree]: http://multimlton.cs.purdue.edu/mML/Notes/research/notes/2014/04/16/Local-Specification.html
