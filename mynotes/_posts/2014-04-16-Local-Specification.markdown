---
layout: post
title:  "Local Specification for Codeec"
date:   2014-04-16 10:55:24
categories: Research Notes
---

Our goal is to describe a specification language that can only express such
consistency assertions that can be *locally checked and enforced without
coordination* (Coordination-free). For example, total order of all operations
can neither be locally checked nor enforced without coordination. As another
example, total order on visible operations,

<div>
\[
visTotal = \forall a,b. \lambda x. vis(a,x) \wedge vis(b,x) \Rightarrow vis(a,b)
\]
</div>

can be locally checked but not enforced; $a$ and $b$ are actions that
correspond to completed operations, whose visibility information can be queried
but not enforced. Now, the question is can we restrict the specification
language such that only coordination-free specifications can be written down.

# Local specification language

<div>
\[
\newcommand{\ALT}{~|~}
\newcommand{\spec}{\overline{\forall a}. \phi \Rightarrow \psi}
\newcommand{\cf}[1]{CoordFree(#1)}
\newcommand{\llbracket}{[\![}
\newcommand{\rrbracket}{]\!]}
\begin{array}{rcl}
a,b,x  & \in & Action \\
lspec  & :=  &  \spec \\
\phi   & :=  & True \ALT vis(a,b) \ALT so(a,b) \ALT inVis(a) \ALT inSo(a) \ALT \phi \odot \phi \\
\psi   & :=  & inVis(a) \ALT \psi \odot \psi \\
\odot  & :=  & \wedge \ALT \vee \\
\end{array}
\]
</div>

The new constructs are $inVis(a)$ and $inSo(a)$ which are equivalent to
$vis(a,x)$ and $so(a,x)$ where $x$ is the action potentially generated by the
operation under focus. Also, we assume that $\wedge$ has higher precendence
than $\vee$, and both $\wedge$ and $\vee$ are associative and commutative.
Moreover, the standard logical equivalences hold $\llbracket P \odot True
\rrbracket = \llbracket P \rrbracket$.

## Examples

Let us look at examples of specifications that can be written down using this
language.

<div>
\begin{array}{rl}
\text{Read my writes :} & \forall a. inSo(a) \Rightarrow inVis(a) \\
\text{Monotonic writes :} & \forall a,b. so(a,b) \wedge inVis(b) \Rightarrow inVis(a) \\
\text{Monotonic reads :} & \forall a,b. vis(a,b) \wedge inSo(b) \Rightarrow inVis(a) \\
\text{Causal visibility :} & \forall a,b. vis(a,b) \wedge inVis(b) \Rightarrow inVis(a)
\end{array}
</div>

# Coordination Freedom Analysis

Let $k(x)$ indicate that $x$ is known. We want to know whether a specification
of the form $\spec$ is coordination free (locally checked and enforced without
coordination). To answer this, we will utilize $\cf{spec}$ which holds for
specifications that are coordination free. Of course, we assume that the
specification does not introduce logical inconsistencies. For example, the
following are logically inconsistent specifications:

* $\forall a,b. so(a,b) \wedge so(b,a) \Rightarrow inVis(a)$ - session order is total.
* $\forall a,b. inSo(a) \wedge vis(b,a) \Rightarrow inVis(b)$ - happens-before is acyclic.

The logically inconsistent specifications are weeded out using the SMT solver
and the set of basic axioms. This **Coordination Freedom** analysis is defined
below:

<div>
\[
\newcommand{\cfxto}{~\overset{ext}{\longrightarrow}~}
\newcommand{\cfcto}{~\overset{chk}{\longrightarrow}~}
\newcommand{\rulesep}{\;\;\;\;\;\;}
\frac{\emptyset \vdash \phi ~\overset{ext~*}{\longrightarrow}~ \Gamma \vdash True \rulesep
      \Gamma \vdash \psi ~\overset{chk~*}{\longrightarrow}~ \Gamma \vdash True}
     {\cf{\spec}} \rulesep
\]
</div>

where

<div>
\[
\begin{array}{rcll}
\Gamma \vdash True \odot \psi & \cfcto & \Gamma \vdash \psi & (C.1)\\
\Gamma, k(a) \vdash inVis(a) \odot \psi & \cfcto & \Gamma, k(a) \vdash True \odot \psi & (C.2) \\ \\

\Gamma \vdash True \odot \phi & \cfxto & \Gamma \vdash \phi & (E.1) \\
\Gamma, k(b) \vdash vis(a,b) \odot \phi & \cfxto & \Gamma, k(a), k(b) \vdash True \odot \phi & (E.2) \\
\Gamma, k(b) \vdash so(a,b) \odot \phi & \cfxto & \Gamma, k(a), k(b) \vdash True \odot \phi & (E.3) \\
\Gamma \vdash inSo(a) \odot \phi & \cfxto & \Gamma, k(a) \vdash True \odot \phi & (E.4) \\
\Gamma \vdash inVis(a) \odot \phi & \cfxto & \Gamma, k(a) \vdash True \odot \phi & (E.5) \\
\end{array}
\]
</div>

## Examples

### Read my writes

<div>
\[
\newcommand{\doExt}{~\overset{ext~*}{\longrightarrow}~}
\newcommand{\doChk}{~\overset{chk~*}{\longrightarrow}~}
\begin{array}{rl}
\text{Spec :} 		& rmw = \forall a. inSo(a) \Rightarrow inVis(a) \\
\text{Extension :} 	& \emptyset \vdash inSo(a)
					  \doExt k(a) \vdash True \\
\text{Check :}		& k(a) \vdash inVis(a)
                      \doChk k(a) \vdash True \\
\end{array}
\]
</div>

Hence, $\cf{rmw}$ holds.

### Causal Visibility

<div>
\[
\begin{array}{rl}
\text{Spec :} 		& cau = \forall a,b. vis(a,b) \wedge inVis(b) \Rightarrow inVis(a) \\
\text{Extension :} 	& \emptyset \vdash inVis(b) \wedge vis(a,b)
                      \doExt k(b) \vdash vis(a,b)
					  \doExt k(a), k(b) \vdash True \\
\text{Check :}		& k(a),k(b) \vdash inVis(a)
                      \doChk k(a), k(b) \vdash True \\
\end{array}
\]
</div>

Hence, $\cf{cau}$ holds. Similarly, monotonic reads and writes are coordination free.

### Final action

Here is an example of a local specification that is not coordination free. This
specification states that the operation is the last operation globally.

<div>
\[
\begin{array}{rl}
\text{Spec :} & last = \forall a. True => inVis(a) \\
\text{Extension :} & \emptyset \vdash True \\
\text{Check :} & \emptyset \vdash inVis(a) \doChk \ldots \\
\end{array}
\]
</div>

The check gets stuck! This indicates that the final action specification is not
coordination free, and requires global knowledge (coordination).

## Enforcing syntactic restriction

The syntactic restriction can be enforced in the specification library using
phantom types. For the local specification language dicussed here, the Haskell
library for constructing the specifications are given below:

{% highlight haskell %}
data LHS
data RHS
data Action
data FOL
data Prop a

forall_ :: (Action -> FOL) -> FOL
(==>) :: Prop LHS -> Prop RHS -> FOL
inVis :: Action -> Prop a
inSo :: Action -> Prop LHS
vis :: Action -> Action -> Prop LHS
so :: Action -> Action -> Prop LHS
(\/) :: Prop a -> Prop a -> Prop a
(/\) :: Prop a -> Prop a -> Prop a

-- Read my writes
rmw :: FOL
rmw = forall_ $ \a -> inSo a ==> inVis a

-- Monotonic writes
mw :: FOL
mw = forall_ $ \a -> forall_ $ \b -> so a b /\ inVis b ==> inVis a

-- Monotonic reads
mr :: FOL
mr = forall_ $ \a -> forall_ $ \b -> vis a b /\ inSo b ==> inVis a

-- Causal visibility
cvis :: FOL
cvis = forall_ $ \a -> forall_ $ \b -> vis a b /\ inVis b ==> inVis a
{% endhighlight %}
